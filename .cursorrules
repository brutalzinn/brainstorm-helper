# Brainstorm Helper - Development Rules

## Code Style & Quality
- NO COMMENTS in code - code should be self-documenting
- Use descriptive variable and function names
- Keep functions small and focused
- Use TypeScript strict typing
- Follow React best practices with hooks

## Security
- NEVER store API keys in localStorage or any persistent storage
- API keys should only exist in memory during the session
- Only store brainstorm conversation data in localStorage (messages, queue, stats)
- Always clear sensitive data when clearing brainstorm

## UI/UX Guidelines
- Mobile-first responsive design
- Use Bootstrap components consistently
- Dark theme as default
- High contrast colors for accessibility
- Touch-friendly button sizes (min 44px)
- Clear visual hierarchy

## File Organization
- Keep components in /src/components/
- Keep hooks in /src/hooks/
- Keep providers in /src/providers/
- Keep types in /src/types/
- Keep services in /src/services/

## Naming Conventions
- PascalCase for components and interfaces
- camelCase for variables and functions
- kebab-case for file names
- Descriptive names that explain purpose

## Performance
- Use React.memo for expensive components
- Use useCallback for event handlers
- Use useMemo for expensive calculations
- Minimize re-renders

## Error Handling
- Always handle errors gracefully
- Show user-friendly error messages
- Log errors to console for debugging
- Never crash the app

## Testing
- Write testable code
- Separate business logic from UI
- Mock external dependencies
- Test user interactions

## Accessibility
- Use semantic HTML
- Add proper ARIA labels
- Ensure keyboard navigation
- Maintain color contrast
- Test with screen readers

## Code Examples

### Good Component Structure
```tsx
interface ComponentProps {
  title: string;
  onAction: (value: string) => void;
  isLoading?: boolean;
}

export const Component: React.FC<ComponentProps> = ({
  title,
  onAction,
  isLoading = false,
}) => {
  const [state, setState] = useState<string>('');
  
  const handleSubmit = useCallback((value: string) => {
    onAction(value);
  }, [onAction]);

  return (
    <div className="component-container">
      <h2>{title}</h2>
    </div>
  );
};
```

### Good Hook Pattern
```tsx
export const useCustomHook = (initialValue: string) => {
  const [value, setValue] = useState(initialValue);
  
  const updateValue = useCallback((newValue: string) => {
    setValue(newValue);
  }, []);
  
  return { value, updateValue };
};
```

## Anti-Patterns to Avoid
- Don't add comments to code
- Don't store API keys persistently
- Don't use class components
- Don't mutate state directly
- Don't ignore TypeScript errors
- Don't create overly complex components
- Don't forget error handling
- Don't ignore accessibility requirements